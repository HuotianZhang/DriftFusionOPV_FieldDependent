# External Model Refactoring

## Overview
This document describes the refactoring of `run_MarcusTransfer_JV` and the creation of the new `external_model.m` file.

## Changes Made

### 1. Modified `run_MarcusTransfer_JV` Function

**File**: `functions/run_MarcusTransfer_JV.m`

**Previous Signature**:
```matlab
function [JJ, VV] = run_MarcusTransfer_JV(lifetime_ex, offset)
```

**New Signature**:
```matlab
function [JJ, VV] = run_MarcusTransfer_JV(VV, offset, lifetime_ex, lambda, RCT)
```

**Key Changes**:
1. **VV as input**: The voltage parameter is now an input that can be:
   - A scalar (e.g., `1.2`) - will simulate from 0 to that value
   - A vector (e.g., `linspace(0, 1.2, 50)`) - will use min/max as Vstart/Vend

2. **Parameter order changed**: Parameters are now in the order: VV, offset, lifetime_ex, lambda, RCT

3. **Lambda and RCT are now parameters**: Previously hardcoded as:
   - `lambda = 0.5` eV
   - `RCT = 1.5` nm
   
   Now they are input parameters, allowing flexibility in Marcus transfer calculations.

4. **Vstart and Vend determination**: Automatically determined from VV input:
   ```matlab
   if isscalar(VV)
       Vend = VV;
       Vstart = 0;
   else
       Vstart = min(VV);
       Vend = max(VV);
   end
   ```

### 2. Created `external_model.m`

**File**: `external_model.m` (in repository root)

**Purpose**: Provides a simplified interface that replaces simple fitting equations (like `Y = k02 * X.^2 + k20`) with physics-based Marcus transfer calculations.

**Signature**:
```matlab
function JJ = external_model(VV, offset, lifetime_ex, lambda, RCT)
```

**Inputs**:
- `VV`: Voltage array (V) - can be a vector
- `offset`: Energy offset between excited state and CT state (eV)
- `lifetime_ex`: Exciton lifetime in picoseconds (ps)
- `lambda`: Reorganization energy (eV)
- `RCT`: Charge transfer distance (nm)

**Output**:
- `JJ`: Current density array (mA/cmÂ²)

**Implementation**: Simple wrapper around `run_MarcusTransfer_JV`:
```matlab
[JJ, ~] = run_MarcusTransfer_JV(VV, offset, lifetime_ex, lambda, RCT);
```

## Usage Examples

### Using `run_MarcusTransfer_JV` directly

```matlab
% With scalar voltage (simulates from 0 to 1.2 V)
[JJ, VV] = run_MarcusTransfer_JV(1.2, 0.05, 10, 0.5, 1.5);

% With voltage vector
VV_input = linspace(0, 1.2, 50);
[JJ, VV] = run_MarcusTransfer_JV(VV_input, 0.05, 10, 0.5, 1.5);
```

### Using `external_model`

```matlab
% Define voltage array
VV = linspace(0, 1.2, 50);

% Call external_model
JJ = external_model(VV, 0.05, 10, 0.5, 1.5);

% Plot
plot(VV, JJ);
xlabel('Voltage [V]');
ylabel('Current Density [mA/cm^2]');
```

## Example Scripts

Two example scripts are provided:

1. **`example_run_MarcusTransfer.m`**: Updated to use the new function signature
2. **`example_external_model.m`**: New script demonstrating `external_model` usage

## Migration Guide

If you have existing code using the old `run_MarcusTransfer_JV` function:

**Old code**:
```matlab
[JJ, VV] = run_MarcusTransfer_JV(10, 0.05);
```

**New code**:
```matlab
% Option 1: Using default lambda and RCT
[JJ, VV] = run_MarcusTransfer_JV(1.2, 0.05, 10, 0.5, 1.5);

% Option 2: Using external_model with voltage vector
VV = linspace(0, 1.2, 50);
JJ = external_model(VV, 0.05, 10, 0.5, 1.5);
```

## Benefits

1. **Flexibility**: VV can now be a custom voltage array
2. **Parameter control**: lambda and RCT are no longer hardcoded
3. **Simple interface**: `external_model` provides a clean wrapper
4. **Physics-based**: Replaces simple polynomial fits with Marcus transfer theory
5. **Backward compatibility**: Can still use scalar voltage for simple cases

## Technical Details

### Marcus Transfer Parameters

- **lambda** (Reorganization energy): Energy penalty for nuclear rearrangement during charge transfer
- **RCT** (Charge transfer distance): Distance between donor and acceptor molecules
- **offset**: Energy difference between excited state and CT state

These parameters are used in `kDis_stark` and `kBak_stark` functions to calculate field-dependent rate constants using Marcus theory.

### Voltage Range Determination

The function automatically handles both scalar and vector inputs:
- **Scalar**: Assumes Vstart=0, Vend=VV
- **Vector**: Uses min(VV) and max(VV) for simulation range
- The simulation returns the actual voltage points generated by the solver

## Files Modified/Created

1. **Modified**: `functions/run_MarcusTransfer_JV.m`
2. **Modified**: `example_run_MarcusTransfer.m`
3. **Created**: `external_model.m`
4. **Created**: `example_external_model.m`
5. **Created**: `EXTERNAL_MODEL_REFACTORING.md` (this file)
